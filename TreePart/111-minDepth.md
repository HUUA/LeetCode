## 二叉树的最小深度

### 题目描述

```
给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
示例:
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度2.
```

### 分析

```
1. 如果根节点是 NULL，说明没有深度。
2. 如果节点的左右儿子都不存在，说明只有自己，节点深度为 1.
3. 如果节点没有左儿子，但是有右儿子，说明最小深度只能在右儿子处获得。这里需要理解一下逻辑，如果一个节点有左儿子，但是没有右儿子，说明这个节点不是叶节点，说明本节点不可能是最小深度，最小深度肯定比本节点要大。（只考虑这一部分的话）叶子只可能出现在右儿子及右儿子的儿子们，所以，要对右儿子做递归。
4. 递归之后为什么要+1呢？因为每返回一次，说明深度+1。
5. 同样的，如果没有右儿子，只有左儿子，那么应该对左儿子进行递归。
6. 最后，选择左右深度较小的那一个，并且+1，如果不+1无法返回根节点，只能到根节点的子节点。
```

### 代码

```c++
int minDepth(TreeNode *root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return 1;
        
        if (root->left == NULL) return minDepth(root->right) + 1;
        else if (root->right == NULL) return minDepth(root->left) + 1;
        else return 1 + min(minDepth(root->left), minDepth(root->right));
    }
```

